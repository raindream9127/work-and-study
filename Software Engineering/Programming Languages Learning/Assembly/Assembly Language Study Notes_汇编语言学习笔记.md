# Index

- [x86处理器架构](#x86处理器架构)
  - [32位x86处理器架构](#32位x86处理器架构)
  - [x86-64处理器架构](#x86-64处理器架构)
- [汇编语言基础](#汇编语言基础)
  - [常用汇编器](#常用汇编器)
  - [汇编语言常量](#汇编语言常量)
  - [汇编语言保留字/关键字](#汇编语言保留字/关键字)
  - [标识符identifier](#标识符identifier)
  - [伪指令directive](#伪指令directive)
指令	4
列表文件listing file	4
数据类型和数据定义	4
数据操作相关运算符和指令	3
操作数类型	4
MOV、MOVZX、MOVSX指令	4
LAHF、SAHF指令	4
XCHG指令	4
加减运算和相关指令	4
OFFSET运算符	4
ALIGH伪指令	4
PTR运算符	4
TYPE和SIZEOF运算符	4
LENGTHOF运算符	4
LABEL伪指令	4
TYPEDEF运算符	4
汇编语言条件判断	4
布尔和比较指令	5
检查奇偶标志	5
置位和清除单个CPU标志	5
JMP指令	5
条件跳转指令	5
LOOP相关指令	5
32位条件控制流伪指令	5
汇编语言整数运算	4
逻辑移位和算术移位	5
MUL指令	5
IMUL指令	5
DIV指令	5
IDIV指令	5
符号扩展指令	5
ADC和SBB指令	5
汇编语言ASCII和非压缩十进制运算	5
压缩十进制运算	5
汇编语言过程	4
PUSH和POP及相关指令	5
CALL和RET指令	5
USES运算符	5
汇编语言高级过程	4
调用规范	5
LEA指令	5
ENTER和LEAVE指令	5
LOCAL伪指令	5
INVOKE伪指令	5
ADDR运算符	5
PROC和ENDP伪指令	5
PROTO伪指令	5
EXTERN伪指令	5
Java虚拟机JVM工作原理	5
汇编语言字符串和数组	4
字符串基本指令	5
汇编语言结构和宏	4
结构体	5
联合union	5
宏过程简述	5
条件汇编伪指令简述	5
宏汇编运算符简介	5
宏函数	5
重复语句伪指令	5
浮点数处理与指令编码	4
FPU浮点数计算单元简介	4
浮点数异常	4
浮点数指令集	4
FINIT初始化	4
FLD加载浮点数值	4
FST，FSTP保存浮点数值	4
FCHS和FABS	4
FADD、FADDP、FIADD	4
FSUB、FSUBP、FISUB	4
FMUL、FMULP、FIMUL	5
FDIV、FDIVP、FIDIV	5
FCOM、FCOMP、FCOMPP	5
FWAIT指令（WAIT）	5
其他FPU指令	5
高级语言接口	5
.MODEL伪指令	5
__asm伪指令	6
部分汇编器特殊语法积累	6
MASM	6
Visual Studio常用功能积累	7
查看OBJ文件中所有过程名	7
查看编译器生成的汇编语言代码	7

# x86处理器架构

## 32位x86处理器架构

1）操作模式：

- 保护模式protected mode——一般的支持虚拟内存的模式
- 虚拟8086模式Virtual-8086——8086虚拟机，仅1MB内存，但可以创建多个
- 实地址模式Real-Address——MS-DOS模式，直接寻址，仅1MB内存和单程序
- 系统管理模式System Management——仅由操作系统和机器开发使用

2）地址空间：

最大4GB，从 P6 处理器开始，一种被称为扩展物理寻址 (extended physical addressing) 的技术使得可以被寻址的物理内存空间增加到 64GB

3）基本程序执行寄存器basic program execution registers

- 8个32位通用寄存器：
  - EAX：扩展累加器extended accumulator，乘除指令默认使用。也用于子程序存放返回值。
  - EBX：
  - ECX：CPU 默认使用 ECX 为循环计数器
  - EDX：
  - EBP：扩展帧指针extended frame pointer，用于引用堆栈数据，指向当前调用堆栈帧首地址。极少作算术和传输。
  - ESP：扩展堆栈指针extended stack pointer，用于寻址堆栈数据，指向调用堆栈的顶部地址。极少作算术和传输。
  - ESI：扩展源变址extended source index，用于高速存储器传输指令，也常常用作基址-偏移量寻址中存放指针数据。
  - EDI：扩展目的变址extended destination index，用于高速存储器传输指令

注：EAX的低16位叫AX，AX的高低8位分别叫AH和AL，以此类推（仅限ABCD这4个通用寄存器可以拆开使用）。

- 6个16位段寄存器：
  - CS
  - SS
  - DS
  - ES
  - FS
  - GS

注：实地址模式中，16 位段寄存器表示的是预先分配的内存区域的基址，这个内存区域称为段。保护模式中，段寄存器中存放的是段描述符表指针。

- 1个指令指针寄存器（EIP）：包含下一条将要执行指令的地址
- 1个处理器状态标志寄存器（EFLAGS）：
  - 控制标志位——控制标志位控制 CPU 的操作。
  - 状态标志位——
  - 进位标志位CF——无符号算术运算结果太大或为负时，设置该标志位
  - 溢出标志位OF——有符号算术运算结果太大或太小时，设置该标志
  - 符号标志位SF——算术或逻辑操作产生负结果时，设置该标志位。
  - 零标志位ZF——算术或逻辑操作产生的结果为零时，设置该标志位。
  - 辅助进位标志位AC——算术操作在 8 位操作数中产生了位 3 向位 4 的进位
  - 奇偶校验标志位PF——结果的最低有效字节包含偶数个 1 时设置，否则清除标志
- MMX寄存器：8 个 64 位 MMX 寄存器支持称为 SIMD的特殊指令
- XMM寄存器：8 个 128 位 XMM 寄存器，它们被用于 SIMD 流扩展指令集
- 浮点单元FPU, floating-point unit：执行高速浮点算术运算。FPU 中有 8 个80位浮点数据寄存器，ST(0)~ST(7)。还有48位指令指针寄存器，48位数据指针寄存器，16位标识寄存器，16位控制寄存器，16位状态寄存器，操作码寄存器。

## x86-64处理器架构

1）操作模式IA-32e：

- 兼容模式
- 64位模式

2）基本执行环境：

64 位模式下，虽然处理器现在只能支持 48 位的地址，但是理论上，地址最大为 64 位。从寄存器来看，64 位模式与 32 位最主要的区别如下所示：

- 16 个 64 位通用寄存器（32 位模式只有 8 个通用寄存器）
- 8 个 80 位浮点寄存器
- 1 个 64 位状态标志寄存器 RFLAGS （只使用低 32 位）
- 1 个 64 位指令指针寄存器 RIP

32 位标志寄存器和指令指针寄存器分别称为 EFLAGS 和 EIP。此外，还有一些 x86 处理器用于多媒体处理的特殊寄存器：

- 8 个 64 位 MMX 寄存器
- 16 个 128 位 XMM 寄存器（32 位模式只有 8 个 XMM 寄存器）

3）通用寄存器的变化：

64 位模式下，操作数的默认大小是 32 位，并且有 8 个通用寄存器。但是，给每条指令加上 REX（寄存器扩展）前缀后，操作数可以达到 64 位，可用通用寄存器的数量也增加到 16 个：32 位模式下的寄存器，再加上 8 个有标号的寄存器，R8 到 R15。下表给出了 REX 前缀下可用的寄存器。

|操作数大小|可用寄存器|
|---|---|
|8 位 |	AL、BL、CL、DL、DIL、SIL、BPL、SPL、R8L、R9L、R10L、R11L、R12L、R13L、R14L、R15L    |
|16 位|	AX、BX、CX、DX、DI、SI、BP、SP、R8W、R9W、R10W、R11W、R12W、R13W、R14W、R15W        |
|32 位|	EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D、R9D、R10D、R11D、R12D、R13D、R14D、R15D|
|64 位|	RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8、R9、R10、R11、R12、R13、R14、R15        |

还有一些需要记住的细节：

- 64 位模式下，单条指令不能同时访问寄存器高字节，如 AH、BH、CH 和 DH，以及新字节寄存器的低字节（如 DIL）。
- 64 位模式下，32 位 EFLAGS 寄存器由 64 位 RFLAGS 寄存器取代。这两个寄存器共享低 32 位，而 RFLAGS 的高 32 位是不使用的。
- 32 位模式和 64 位模式具有相同的状态标志。

# 汇编语言基础

## 常用汇编器

- Microsoft 宏汇编器（称为 MASM）
- TASM（Turbo 汇编器）
- NASM（Netwide 汇编器）
- MASM32（MASM 的一种变体）
- GAS（GNU 汇编器）和 NASM 是两种基于 Linux 的汇编器

在这些汇编器中，NASM 的语法与 MASM 的最相似。

汇编语言的指令虽然一般来讲是和机器指令对应的，是否是一对一取决于指令集具体的结构设计，但汇编语言已经是人类可读的最接近机器语言逻辑的语言形式，它也是一种编程语言。如何将其转化为真正的机器指令和可执行程序仍需要汇编器做很多除了翻译以外的工作，亦即汇编指令的编译器。而使得程序员可以在基础操作外更轻松使用更多编程功能的要素便是伪指令和运算符，它们实际上就是代替了一些经常需要使用的汇编指令序列。因此可以说含伪指令的汇编程序会被编译为不含伪指令的汇编程序（亦即编译过程中的中间步骤），进而编译为目标代码。

## 汇编语言常量

指令层面，常量被直接编码于指令，所以无法修改。

## 汇编语言保留字/关键字

保留字（reserved words）有特殊意义并且只能在其正确的上下文中使用。默认情况下，保留字是没有大小写之分的。比如，MOV 与 mov、Mov 是相同的。

保留字有不同的类型：

- 指令助记符，如 MOV、ADD 和 MUL。
- 寄存器名称。
- 伪指令，告诉汇编器如何汇编程序。
- 属性，提供变量和操作数的大小与使用信息。例如 BYTE 和 WORD。
- 运算符，在常量表达式中使用。
- 预定义符号，比如 @data，它在汇编时返回常量的整数值。

## 标识符identifier

标识符是由程序员选择的名称，它用于标识变量、常数、子程序和代码标签。

标识符的形成有一些规则：
	
- 可以包含 1 到 247 个字符。
- 不区分大小写。
- 首字符须为字母 (A---Z, a---z) 、下划线 (_)、@、? 或 $。其后的字符可以是数字。
- 标识符不能与汇编器保留字相同。

提示：可以在运行汇编器时，添加 -Cp 命令行切换项来使得所有关键字和标识符变成大小写敏感。

## 伪指令directive

伪指令是嵌入源代码中的命令，由汇编器识别和执行。伪指令不在运行时执行，但是它们可以定义变量、宏和子程序；为内存段分配名称，执行许多其他与汇编器相关的日常任务。默认情况下，伪指令不区分大小写。

尽管 Intel 处理器所有的汇编器使用相同的指令集，但是通常它们有着不同的伪指令。比如，Microsoft 汇编器的 REPT 伪指令对其他一些汇编器就是无法识别的。一般由.点号开始的命令、带有全部大写标识符的命令、不符合一般指令格式的命令都是伪指令。

汇编器伪指令的一个重要功能是定义程序区段，也称为段 (segment)。程序中的段具有不同的作用。

1）段声明伪指令

- .data一个用于定义变量的段，未初始化数据在此段仍然占用空间
- .data? 一个用来声明未初始化数据的段。未初始化数据在此段不占用空间
- .code伪指令标识的程序区段包含了可执行的指令

2）系统设置与调用伪指令

32位：

- .stack 标识的程序区段定义了运行时堆栈，并设置了其大小：.stack 100h
- .386 它表示这是一个 32 位程序，能访问 32 位寄存器和地址。
- .model memory_mode call_convention 可选择程序的内存模式（如flat）并确定子程序的调用规范（如stdcall）
- function PROTO, paraname1:type [,para2:type…]	声明子程序原型和参数列表
- INVOKE function, arg1 [,arg2…] 调用子程序function并附带参数列表
- END main 标识程序结尾位置以及程序的入口（main）。

64位：

- function PROTO 声明子程序原型，无参数列表，参数由寄存器通过mov传输，调用通过call指令
- END 标识程序结尾位置，不需注明程序入口

3）等号=、EQU、TEXTEQU伪指令

- 等号伪指令（equal-sign directive）把一个符号名称与一个整数表达式连接起来，这在汇编语言中相当于宏定义。

```
name = expression
```

- EQU 伪指令把一个符号名称与一个整数表达式或一个任意文本连接起来，它有 3 种格式：

```
name EQU expression
name EQU symbol
name EQU <text>
```

第一种格式中，expression 必须是一个有效整数表达式。第二种格式中，symbol 是一个已存在的符号名称，已经用 = 或 EQU 定义过了。第三种格式中，任何文本都可以岀现在<...>内。当汇编器在程序后面遇到 name 时，它就用整数值或文本来代替符号。

- TEXTEQU 伪指令，类似于 EQU，创建了文本宏（text macro）。它有 3 种格式：第一种为名称分配的是文本；第二种分配的是已有文本宏的内容；第三种分配的是整数常量表达式：

```	
name TEXTEQU <text>
name TEXTEQU textmacro
name TEXTEQU %constExpr  ;%运算符的介绍见后文
```

文本宏可以相互嵌套构建。

注意：在同一源代码文件中，用 EQU 定义的符号不能被重新定义，而等号=和TEXTEQU定义的符号可随时重新定义。

4）$运算符（当前地址计数器）

$运算符（当前地址计数器）返回当前程序语句的偏移量。在下例中，从当前地址计数器（$）中减去 list 的偏移量，计算得到 ListSize：

```	
list BYTE 10,20,30,40
ListSize = ($ - list)
```

这是$运算符最常用的用法之一，即计算字符串或数组长度。ListSize 必须紧跟在 list 的后面。且如果类型是BYTE长度的n倍，那相应的结果需要缩小n倍。

## 指令

一条指令有四个组成部分：
	标号（可选）
	指令助记符（必需）
	操作数（通常是必需的）
	注释（可选）
不同部分的位置安排如下所示：
	(label:) mnemonic (operands) (;comment)
1）标号
标号（label）是一种标识符，是指令和数据的位置标记。标号位于指令的前端，表示指令的地址。同样，标号也位于变量的前端，表示变量的地址。标号有两种类型：数据标号和代码标号。
·数据标号标识变量的位置，它提供了一种方便的手段在代码中引用该变量。比如，下面定义了一个名为 count 的变量（count实则代表一个数据区的偏移位置）：
	count DWORD 100
汇编器为每个标号分配一个数字地址。可以在一个标号后面定义多个数据项。在下面的例子中，array 定义了第一个数字（1024）的位置，其他数字在内存中的位置紧随其后：
	array DWORD 1024, 2048
      	      DWORD 4096, 8192
上例也可以写成：（对于LENGTHOF运算符有区别）
	array DWORD 1024, 2048,
	            4096, 8192
·程序代码区（指令所在区段）的标号必须用冒号（:）结束。这样的标号仅在当前过程（函数、方法、子程序）中有效，解除这个限制的方法是定义全局标号，即在名字后面加双冒号 (::)。代码标号用作跳转和循环指令的目标。例如，下面的 JMP 指令创建一个循环，将程序控制传递给标号 target 标识的位置：
	target:
		mov ax,bx
		...
		jmp target
代码标号可以与指令在同一行上，也可以自己独立一行。标号命名规则要求，只要每个标号在其封闭子程序页中是唯一的，那么就可以多次使用相同的标号。
2）指令助记符
3）操作数
操作数是指令输入输出的数值。汇编语言指令操作数的个数范围是 0〜3 个，每个操作数可以是寄存器、内存操作数、整数表达式和输入输岀端口。
生成内存操作数有不同的方法，比如，使用变量名、带方括号的寄存器等。变量名暗示了变量地址，并指示计算机使用给定地址的内存内容。
操作数有固有顺序。当指令有多个操作数时，通常第一个操作数被称为目的操作数，第二个及之后的操作数被称为源操作数（source operand）。一般源操作数用来计算，目的操作数用来修改和写入。当只有一个操作数时，可能是源操作数或目的操作数（如PUSH和POP）。
4）注释
注释有两种指定方法：
单行注释，用分号（;）开始。汇编器将忽略在同一行上分号之后的所有字符。
块注释，用 COMMENT 伪指令和一个用户定义的符号开始。汇编器将忽略其后所有的文本行，直到相同的用户定义符号出现为止。
示例如下：
	COMMENT !
		This line is a comment.
		This line is also a comment.
	!
5）NOP（空操作）指令
最安全（也是最无用）的指令是 NOP（空操作）。它在程序空间中占有一个字节，但是不做任何操作。它有时被编译器和汇编器用于将代码对齐到有效的地址边界。

列表文件listing file
列表文件 (listing file) 包括了程序源文件的副本，再加上行号、每条指令的数字地址、每条指令的机器代码字节（十六进制）以及符号表。符号表中包含了程序中所有标识符的名称、段和相关信息。
若想告诉 Visual Studio 生成列表文件，则在打开项目时按下述步骤操作：在 Project 菜单中选择 Properties，在 Configuration Properties 下，选择 Microsoft Macro Assemblero 然后选择 Listing File。在对话框中，设置 Generate Preprocessed Source Listing 为 Yes，设置 List All Available Information 为 Yes。


